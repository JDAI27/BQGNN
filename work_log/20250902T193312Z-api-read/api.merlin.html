

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>merlin package &mdash; merlinquantum 0.0.post53 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/style.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/fonts.css" />

  
    <link rel="shortcut icon" href="../../_static/Merlin icon white 32x32.ico"/>
      <script src="../../_static/jquery.js"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
      <script src="../../_static/doctools.js"></script>
      <script src="../../_static/sphinx_highlight.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="merlin.core package" href="merlin.core.html" />
    <link rel="prev" title="API Reference" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            merlinquantum
              <img src="../../_static/Merlin logo white 160x160.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../research/index.html">Expert Area</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/index.html">Notebooks</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="modules.html">API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance.html">Performance</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">merlinquantum</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Reference</a></li>
          <li class="breadcrumb-item"><a href="modules.html">API Reference</a></li>
      <li class="breadcrumb-item active">merlin package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/reference/api/merlin.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
               
  <section id="module-merlin">
<span id="merlin-package"></span><h1>merlin package<a class="headerlink" href="#module-merlin" title="Permalink to this heading"></a></h1>
<p>Merlin - Photonic Quantum Neural Networks for PyTorch</p>
<p>A comprehensive framework for integrating photonic quantum circuits
into PyTorch neural networks with automatic differentiation support.</p>
<dl class="py class">
<dt class="sig sig-object py" id="merlin.Ansatz">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">Ansatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">PhotonicBackend</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_mapping_strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">OutputMappingStrategy.LINEAR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.Ansatz" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Complete configuration for a quantum neural network layer.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.AnsatzFactory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">AnsatzFactory</span></span><a class="headerlink" href="#merlin.AnsatzFactory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Factory for creating quantum layer ansatzes (complete configurations).</p>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.AnsatzFactory.create">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">PhotonicBackend</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_mapping_strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">OutputMappingStrategy.LINEAR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.AnsatzFactory.create" title="Permalink to this definition"></a></dt>
<dd><p>Create a complete ansatz configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="merlin.core.ansatz.html#merlin.core.ansatz.Ansatz" title="merlin.core.ansatz.Ansatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ansatz</span></code></a></p>
</dd>
</dl>
<dl class="simple">
<dt>Args:</dt><dd><p>PhotonicBackend (PhotonicBackend): The backend configuration to use.
input_size (int): Size of the input feature vector.
output_size (int | None): Size of the output vector. If None, it is defined by the backend.
output_mapping_strategy (OutputMappingStrategy): Strategy for mapping outputs.
device (torch.device | None): Device to run computations on.
dtype (torch.dtype | None): Data type for computations.</p>
</dd>
<dt>Returns:</dt><dd><p>Ansatz: A complete ansatz configuration for the quantum layer.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.AutoDiffProcess">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">AutoDiffProcess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'multinomial'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.AutoDiffProcess" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Handles automatic differentiation backend and sampling noise integration.</p>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.AutoDiffProcess.autodiff_backend">
<span class="sig-name descname"><span class="pre">autodiff_backend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">needs_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.AutoDiffProcess.autodiff_backend" title="Permalink to this definition"></a></dt>
<dd><p>Determine sampling configuration based on gradient requirements.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.CircuitConverter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">CircuitConverter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_specs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.complex64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">device(type='cpu')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.CircuitConverter" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Convert a parameterized Perceval circuit into a differentiable PyTorch unitary matrix.</p>
<p>This class converts Perceval quantum circuits into PyTorch tensors that can be used
in neural network training with automatic differentiation. It supports batch processing
for efficient training and handles various quantum components like beam splitters,
phase shifters, and unitary operations.</p>
<dl>
<dt>Supported Components:</dt><dd><ul class="simple">
<li><p>PS (Phase Shifter)</p></li>
<li><p>BS (Beam Splitter)</p></li>
<li><p>PERM (Permutation)</p></li>
<li><p>Unitary (Generic unitary matrix)</p></li>
<li><p>Barrier (no-op, removed during compilation)</p></li>
</ul>
</dd>
<dt>Attributes:</dt><dd><p>circuit: The Perceval circuit to convert
param_mapping: Maps parameter names to tensor indices
device: PyTorch device for tensor operations
tensor_cdtype: Complex tensor dtype
tensor_fdtype: Float tensor dtype</p>
</dd>
<dt>Example:</dt><dd><p>Basic usage with a single phase shifter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">perceval</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pcvl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">merlin.pcvl_pytorch.locirc_to_tensor</span><span class="w"> </span><span class="kn">import</span> <span class="n">CircuitConverter</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a simple circuit with one phase shifter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span> <span class="o">=</span> <span class="n">pcvl</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">pcvl</span><span class="o">.</span><span class="n">PS</span><span class="p">(</span><span class="n">pcvl</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="s2">&quot;phi&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Convert to PyTorch with gradient tracking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">converter</span> <span class="o">=</span> <span class="n">CircuitConverter</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">input_specs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi_params</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.5</span><span class="p">],</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unitary</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">(</span><span class="n">phi_params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">unitary</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># torch.Size([1, 1])</span>
</pre></div>
</div>
<p>Multiple parameters with grouping:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Circuit with multiple phase shifters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span> <span class="o">=</span> <span class="p">(</span><span class="n">pcvl</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>           <span class="o">//</span> <span class="n">pcvl</span><span class="o">.</span><span class="n">PS</span><span class="p">(</span><span class="n">pcvl</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="s2">&quot;theta1&quot;</span><span class="p">))</span>
<span class="gp">... </span>           <span class="o">//</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pcvl</span><span class="o">.</span><span class="n">PS</span><span class="p">(</span><span class="n">pcvl</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="s2">&quot;theta2&quot;</span><span class="p">))))</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">converter</span> <span class="o">=</span> <span class="n">CircuitConverter</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">input_specs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">theta_params</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unitary</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">(</span><span class="n">theta_params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">unitary</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># torch.Size([2, 2])</span>
</pre></div>
</div>
<p>Batch processing for training:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Batch of parameter values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_params</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]],</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">converter</span> <span class="o">=</span> <span class="n">CircuitConverter</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">input_specs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_unitary</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">(</span><span class="n">batch_params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">batch_unitary</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># torch.Size([3, 1, 1])</span>
</pre></div>
</div>
<p>Training integration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Training loop with beam splitter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span> <span class="o">=</span> <span class="n">pcvl</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="n">pcvl</span><span class="o">.</span><span class="n">BS</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">pcvl</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="s2">&quot;theta&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">converter</span> <span class="o">=</span> <span class="n">CircuitConverter</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.5</span><span class="p">],</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">([</span><span class="n">theta</span><span class="p">],</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">unitary</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">loss</span> <span class="o">=</span> <span class="n">some_loss_function</span><span class="p">(</span><span class="n">unitary</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.CircuitConverter.set_dtype">
<span class="sig-name descname"><span class="pre">set_dtype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.CircuitConverter.set_dtype" title="Permalink to this definition"></a></dt>
<dd><p>Set the tensor data types for float and complex operations.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dtype: Target dtype (float32/complex64 or float64/complex128)</p>
</dd>
<dt>Raises:</dt><dd><p>TypeError: If dtype is not supported</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlin.CircuitConverter.to">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.CircuitConverter.to" title="Permalink to this definition"></a></dt>
<dd><p>Move the converter to a specific device and dtype.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dtype: Target tensor dtype (float32/complex64 or float64/complex128)
device: Target device (string or torch.device)</p>
</dd>
<dt>Returns:</dt><dd><p>Self for method chaining</p>
</dd>
<dt>Raises:</dt><dd><p>TypeError: If device type or dtype is not supported</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlin.CircuitConverter.to_tensor">
<span class="sig-name descname"><span class="pre">to_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">input_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.CircuitConverter.to_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Convert the parameterized circuit to a PyTorch unitary tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>Args:</dt><dd><p>*input_params: Variable number of parameter tensors. Each tensor has shape (num_params,) or (batch_size, num_params) corresponding to input_specs order.
batch_size: Explicit batch size. If None, inferred from input tensors.</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Complex unitary tensor of shape (circuit.m, circuit.m) for single samples</dt><dd><p>or (batch_size, circuit.m, circuit.m) for batched inputs.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If wrong number of input tensors provided.
TypeError: If input_params is not a list or tuple.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.CircuitGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">CircuitGenerator</span></span><a class="headerlink" href="#merlin.CircuitGenerator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Utility class for generating quantum photonic circuits.</p>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.CircuitGenerator.generate_circuit">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate_circuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_modes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_features</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.CircuitGenerator.generate_circuit" title="Permalink to this definition"></a></dt>
<dd><p>Generate a quantum circuit based on specified type.</p>
</dd></dl>

</dd></dl>

<dl class="py class enum">
<dt class="sig sig-object py" id="merlin.CircuitType">
<em class="property"><span class="pre">enum</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">CircuitType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.CircuitType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="merlin.sampling.strategies.html#merlin.sampling.strategies.Enum" title="enum.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a></p>
<p>Quantum circuit topology types.</p>
<p>Valid values are as follows:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.CircuitType.PARALLEL_COLUMNS">
<span class="sig-name descname"><span class="pre">PARALLEL_COLUMNS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CircuitType.PARALLEL_COLUMNS:</span> <span class="pre">'parallel_columns'&gt;</span></em><a class="headerlink" href="#merlin.CircuitType.PARALLEL_COLUMNS" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.CircuitType.SERIES">
<span class="sig-name descname"><span class="pre">SERIES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CircuitType.SERIES:</span> <span class="pre">'series'&gt;</span></em><a class="headerlink" href="#merlin.CircuitType.SERIES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.CircuitType.PARALLEL">
<span class="sig-name descname"><span class="pre">PARALLEL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CircuitType.PARALLEL:</span> <span class="pre">'parallel'&gt;</span></em><a class="headerlink" href="#merlin.CircuitType.PARALLEL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.FeatureEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">FeatureEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">feature_count</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.FeatureEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Utility class for encoding classical features into quantum circuit parameters.</p>
<p>This class provides methods to encode normalized classical features into parameters
that can be used to configure quantum circuits. Different encoding strategies are
supported depending on the circuit type.</p>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.FeatureEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circuit_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_modes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandwidth_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_shifters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.FeatureEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encode normalized features into quantum circuit parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>Args:</dt><dd><p>X_norm: Normalized input features of shape (batch_size, num_features)
circuit_type: Type of quantum circuit architecture
n_modes: Number of modes in the quantum circuit
bandwidth_coeffs: Optional bandwidth tuning coefficients for each feature dimension
total_shifters: Optional total number of phase shifters (unused in current implementation)</p>
</dd>
<dt>Returns:</dt><dd><p>Encoded parameters tensor of shape (batch_size, num_parameters)</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If circuit_type is not supported</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.LexGroupingMapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">LexGroupingMapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.LexGroupingMapper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Maps probability distributions using lexicographical grouping.</p>
<p>This mapper groups consecutive elements of the probability distribution into
equal-sized buckets and sums them to produce the output. If the input size
is not evenly divisible by the output size, padding is applied.</p>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.LexGroupingMapper.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">probability_distribution</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.LexGroupingMapper.forward" title="Permalink to this definition"></a></dt>
<dd><p>Group probability distribution into equal-sized buckets.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>Args:</dt><dd><p>probability_distribution: Input probability tensor of shape (batch_size, input_size) or (input_size,)</p>
</dd>
<dt>Returns:</dt><dd><p>Grouped probability tensor of shape (batch_size, output_size) or (output_size,)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.ModGroupingMapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">ModGroupingMapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.ModGroupingMapper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Maps probability distributions using modulo-based grouping.</p>
<p>This mapper groups elements of the probability distribution based on their
index modulo the output size. Elements with the same modulo value are summed
together to produce the output.</p>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.ModGroupingMapper.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">probability_distribution</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.ModGroupingMapper.forward" title="Permalink to this definition"></a></dt>
<dd><p>Group probability distribution based on indices modulo output_size.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>Args:</dt><dd><p>probability_distribution: Input probability tensor of shape (batch_size, input_size) or (input_size,)</p>
</dd>
<dt>Returns:</dt><dd><p>Grouped probability tensor of shape (batch_size, output_size) or (output_size,)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.OutputMapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">OutputMapper</span></span><a class="headerlink" href="#merlin.OutputMapper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Handles mapping quantum probability distributions to classical outputs.</p>
<p>This class provides factory methods for creating different types of output mappers
that convert quantum probability distributions to classical neural network outputs.</p>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.OutputMapper.create_mapping">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strategy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.OutputMapper.create_mapping" title="Permalink to this definition"></a></dt>
<dd><p>Create an output mapping based on the specified strategy.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>strategy: The output mapping strategy to use
input_size: Size of the input probability distribution
output_size: Desired size of the output tensor</p>
</dd>
<dt>Returns:</dt><dd><p>A PyTorch module that maps input_size to output_size</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If strategy is unknown or sizes are incompatible for ‘none’ strategy</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class enum">
<dt class="sig sig-object py" id="merlin.OutputMappingStrategy">
<em class="property"><span class="pre">enum</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">OutputMappingStrategy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.OutputMappingStrategy" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="merlin.sampling.strategies.html#merlin.sampling.strategies.Enum" title="enum.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a></p>
<p>Strategy for mapping quantum probability distributions to classical outputs.</p>
<p>Valid values are as follows:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.OutputMappingStrategy.LINEAR">
<span class="sig-name descname"><span class="pre">LINEAR</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;OutputMappingStrategy.LINEAR:</span> <span class="pre">'linear'&gt;</span></em><a class="headerlink" href="#merlin.OutputMappingStrategy.LINEAR" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.OutputMappingStrategy.GROUPING">
<span class="sig-name descname"><span class="pre">GROUPING</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;OutputMappingStrategy.GROUPING:</span> <span class="pre">'grouping'&gt;</span></em><a class="headerlink" href="#merlin.OutputMappingStrategy.GROUPING" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.OutputMappingStrategy.LEXGROUPING">
<span class="sig-name descname"><span class="pre">LEXGROUPING</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;OutputMappingStrategy.LEXGROUPING:</span> <span class="pre">'lexgrouping'&gt;</span></em><a class="headerlink" href="#merlin.OutputMappingStrategy.LEXGROUPING" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.OutputMappingStrategy.MODGROUPING">
<span class="sig-name descname"><span class="pre">MODGROUPING</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;OutputMappingStrategy.MODGROUPING:</span> <span class="pre">'modgrouping'&gt;</span></em><a class="headerlink" href="#merlin.OutputMappingStrategy.MODGROUPING" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.OutputMappingStrategy.NONE">
<span class="sig-name descname"><span class="pre">NONE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;OutputMappingStrategy.NONE:</span> <span class="pre">'none'&gt;</span></em><a class="headerlink" href="#merlin.OutputMappingStrategy.NONE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.PhotonicBackend">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">PhotonicBackend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_modes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_photons</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">StatePattern.PERIODIC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_bandwidth_tuning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reservoir_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.PhotonicBackend" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Configuration container for quantum layer experiments.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.QuantumLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">QuantumLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ansatz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circuit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_photons</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trainable_parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_mapping_strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">OutputMappingStrategy.LINEAR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'multinomial'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_bunching</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_photons</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.QuantumLayer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Enhanced Quantum Neural Network Layer with factory-based architecture.</p>
<p>This layer can be created either from:
1. An Ansatz object (from AnsatzFactory) - for auto-generated circuits
2. Direct parameters - for custom circuits (backward compatible)</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>index_photons (List[Tuple[int, int]], optional): List of tuples (min_mode, max_mode)</dt><dd><p>constraining where each photon can be placed. The first_integer is the lowest
index layer a photon can take and the second_integer is the highest index.
If None, photons can be placed in any mode from 0 to m-1.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.QuantumLayer.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">input_parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.QuantumLayer.forward" title="Permalink to this definition"></a></dt>
<dd><p>Forward pass through the quantum layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlin.QuantumLayer.get_index_photons_info">
<span class="sig-name descname"><span class="pre">get_index_photons_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#merlin.QuantumLayer.get_index_photons_info" title="Permalink to this definition"></a></dt>
<dd><p>Get information about index_photons constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>Returns:</dt><dd><p>dict: Information about photon placement constraints</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlin.QuantumLayer.prepare_parameters">
<span class="sig-name descname"><span class="pre">prepare_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.QuantumLayer.prepare_parameters" title="Permalink to this definition"></a></dt>
<dd><p>Prepare parameter list for circuit evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlin.QuantumLayer.set_sampling_config">
<span class="sig-name descname"><span class="pre">set_sampling_config</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.QuantumLayer.set_sampling_config" title="Permalink to this definition"></a></dt>
<dd><p>Update sampling configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlin.QuantumLayer.simple">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">simple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reservoir_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_mapping_strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">OutputMappingStrategy.NONE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_bunching</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.QuantumLayer.simple" title="Permalink to this definition"></a></dt>
<dd><p>Simplified interface for creating a QuantumLayer.</p>
<p>Uses SERIES circuit type with PERIODIC state pattern as defaults.
Automatically calculates the number of modes based on n_params.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>input_size (int): Size of the input vector
n_params (int): Total number of parameters desired (default: 100). Formula: n_params = 2 * n_modes^2
shots (int): Number of shots for sampling (default: 0)
reservoir_mode (bool): Whether to use reservoir mode (default: False)
output_size (int, optional): Output dimension. If None, uses distribution size
output_mapping_strategy: How to map quantum output to classical output
device: PyTorch device
dtype: PyTorch dtype
no_bunching: Whether to exclude states with multiple photons per mode</p>
</dd>
<dt>Returns:</dt><dd><p>QuantumLayer: Configured quantum layer instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="merlin.QuantumLayer.to">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.QuantumLayer.to" title="Permalink to this definition"></a></dt>
<dd><p>Move and/or cast the parameters and buffers.</p>
<p>This can be called as</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_blocking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_blocking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_blocking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory_format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.channels_last</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p>Its signature is similar to <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.to()</span></code>, but only accepts
floating point or complex <code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code>s. In addition, this method will
only cast the floating point or complex parameters and buffers to <code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code>
(if given). The integral parameters and buffers will be moved
<code class="xref py py-attr docutils literal notranslate"><span class="pre">device</span></code>, if that is given, but with dtypes unchanged. When
<code class="xref py py-attr docutils literal notranslate"><span class="pre">non_blocking</span></code> is set, it tries to convert/move asynchronously
with respect to the host if possible, e.g., moving CPU Tensors with
pinned memory to CUDA devices.</p>
<p>See below for examples.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method modifies the module in-place.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>device (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code>): the desired device of the parameters</dt><dd><p>and buffers in this module</p>
</dd>
<dt>dtype (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code>): the desired floating point or complex dtype of</dt><dd><p>the parameters and buffers in this module</p>
</dd>
<dt>tensor (torch.Tensor): Tensor whose dtype and device are the desired</dt><dd><p>dtype and device for all parameters and buffers in this module</p>
</dd>
<dt>memory_format (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.memory_format</span></code>): the desired memory</dt><dd><p>format for 4D parameters and buffers in this module (keyword
only argument)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Module: self</p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># xdoctest: +IGNORE_WANT(&quot;non-deterministic&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span><span class="o">.</span><span class="n">weight</span>
<span class="go">Parameter containing:</span>
<span class="go">tensor([[ 0.1913, -0.3420],</span>
<span class="go">        [-0.5113, -0.2325]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="go">Linear(in_features=2, out_features=2, bias=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span><span class="o">.</span><span class="n">weight</span>
<span class="go">Parameter containing:</span>
<span class="go">tensor([[ 0.1913, -0.3420],</span>
<span class="go">        [-0.5113, -0.2325]], dtype=torch.float64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gpu1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda:1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">gpu1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">half</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Linear(in_features=2, out_features=2, bias=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span><span class="o">.</span><span class="n">weight</span>
<span class="go">Parameter containing:</span>
<span class="go">tensor([[ 0.1914, -0.3420],</span>
<span class="go">        [-0.5112, -0.2324]], dtype=torch.float16, device=&#39;cuda:1&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
<span class="go">Linear(in_features=2, out_features=2, bias=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span><span class="o">.</span><span class="n">weight</span>
<span class="go">Parameter containing:</span>
<span class="go">tensor([[ 0.1914, -0.3420],</span>
<span class="go">        [-0.5112, -0.2324]], dtype=torch.float16)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cdouble</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span><span class="o">.</span><span class="n">weight</span>
<span class="go">Parameter containing:</span>
<span class="go">tensor([[ 0.3741+0.j,  0.2382+0.j],</span>
<span class="go">        [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cdouble</span><span class="p">))</span>
<span class="go">tensor([[0.6122+0.j, 0.1150+0.j],</span>
<span class="go">        [0.6122+0.j, 0.1150+0.j],</span>
<span class="go">        [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.SamplingProcess">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">SamplingProcess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'multinomial'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.SamplingProcess" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Handles quantum measurement sampling with different methods.</p>
<p>This class provides functionality to simulate quantum measurement noise
by applying different sampling strategies to probability distributions.</p>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.SamplingProcess.pcvl_sampler">
<span class="sig-name descname"><span class="pre">pcvl_sampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distribution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.SamplingProcess.pcvl_sampler" title="Permalink to this definition"></a></dt>
<dd><p>Apply sampling noise to a probability distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>Args:</dt><dd><p>distribution: Input probability distribution tensor
method: Sampling method to use (‘multinomial’, ‘binomial’, or ‘gaussian’), defaults to the initialized method
shots: Number of measurement shots to simulate</p>
</dd>
<dt>Returns:</dt><dd><p>Noisy probability distribution after sampling</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If method is not one of the valid options</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="merlin.StateGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">StateGenerator</span></span><a class="headerlink" href="#merlin.StateGenerator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Utility class for generating photonic input states.</p>
<dl class="py method">
<dt class="sig sig-object py" id="merlin.StateGenerator.generate_state">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_modes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_photons</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_pattern</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.StateGenerator.generate_state" title="Permalink to this definition"></a></dt>
<dd><p>Generate an input state based on specified pattern.</p>
</dd></dl>

</dd></dl>

<dl class="py class enum">
<dt class="sig sig-object py" id="merlin.StatePattern">
<em class="property"><span class="pre">enum</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">StatePattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.StatePattern" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="merlin.sampling.strategies.html#merlin.sampling.strategies.Enum" title="enum.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a></p>
<p>Input photon state patterns.</p>
<p>Valid values are as follows:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.StatePattern.DEFAULT">
<span class="sig-name descname"><span class="pre">DEFAULT</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;StatePattern.DEFAULT:</span> <span class="pre">'default'&gt;</span></em><a class="headerlink" href="#merlin.StatePattern.DEFAULT" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.StatePattern.SPACED">
<span class="sig-name descname"><span class="pre">SPACED</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;StatePattern.SPACED:</span> <span class="pre">'spaced'&gt;</span></em><a class="headerlink" href="#merlin.StatePattern.SPACED" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.StatePattern.SEQUENTIAL">
<span class="sig-name descname"><span class="pre">SEQUENTIAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;StatePattern.SEQUENTIAL:</span> <span class="pre">'sequential'&gt;</span></em><a class="headerlink" href="#merlin.StatePattern.SEQUENTIAL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="merlin.StatePattern.PERIODIC">
<span class="sig-name descname"><span class="pre">PERIODIC</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;StatePattern.PERIODIC:</span> <span class="pre">'periodic'&gt;</span></em><a class="headerlink" href="#merlin.StatePattern.PERIODIC" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="merlin.build_slos_distribution_computegraph">
<span class="sig-prename descclassname"><span class="pre">merlin.</span></span><span class="sig-name descname"><span class="pre">build_slos_distribution_computegraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_photons</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_map_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_bunching</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.float32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_photons</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#merlin.build_slos_distribution_computegraph" title="Permalink to this definition"></a></dt>
<dd><p>Build a computation graph for Strong Linear Optical Simulation (SLOS) algorithm
that can be reused for multiple unitaries.</p>
<p>[existing docstring…]</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="merlin.pcvl_pytorch.slos_torchscript.html#merlin.pcvl_pytorch.slos_torchscript.SLOSComputeGraph" title="merlin.pcvl_pytorch.slos_torchscript.SLOSComputeGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">SLOSComputeGraph</span></code></a></p>
</dd>
</dl>
</dd></dl>

<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="merlin.core.html">merlin.core package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.AbstractComputationProcess"><code class="docutils literal notranslate"><span class="pre">AbstractComputationProcess</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.AbstractComputationProcess.compute"><code class="docutils literal notranslate"><span class="pre">AbstractComputationProcess.compute()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.Ansatz"><code class="docutils literal notranslate"><span class="pre">Ansatz</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.AnsatzFactory"><code class="docutils literal notranslate"><span class="pre">AnsatzFactory</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.AnsatzFactory.create"><code class="docutils literal notranslate"><span class="pre">AnsatzFactory.create()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.CircuitGenerator"><code class="docutils literal notranslate"><span class="pre">CircuitGenerator</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.CircuitGenerator.generate_circuit"><code class="docutils literal notranslate"><span class="pre">CircuitGenerator.generate_circuit()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.CircuitType"><code class="docutils literal notranslate"><span class="pre">CircuitType</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.CircuitType.PARALLEL_COLUMNS"><code class="docutils literal notranslate"><span class="pre">CircuitType.PARALLEL_COLUMNS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.CircuitType.SERIES"><code class="docutils literal notranslate"><span class="pre">CircuitType.SERIES</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.CircuitType.PARALLEL"><code class="docutils literal notranslate"><span class="pre">CircuitType.PARALLEL</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.ComputationProcess"><code class="docutils literal notranslate"><span class="pre">ComputationProcess</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.ComputationProcess.compute"><code class="docutils literal notranslate"><span class="pre">ComputationProcess.compute()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.ComputationProcess.compute_with_keys"><code class="docutils literal notranslate"><span class="pre">ComputationProcess.compute_with_keys()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.ComputationProcessFactory"><code class="docutils literal notranslate"><span class="pre">ComputationProcessFactory</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.ComputationProcessFactory.create"><code class="docutils literal notranslate"><span class="pre">ComputationProcessFactory.create()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.PhotonicBackend"><code class="docutils literal notranslate"><span class="pre">PhotonicBackend</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.QuantumLayer"><code class="docutils literal notranslate"><span class="pre">QuantumLayer</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.QuantumLayer.forward"><code class="docutils literal notranslate"><span class="pre">QuantumLayer.forward()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.QuantumLayer.get_index_photons_info"><code class="docutils literal notranslate"><span class="pre">QuantumLayer.get_index_photons_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.QuantumLayer.prepare_parameters"><code class="docutils literal notranslate"><span class="pre">QuantumLayer.prepare_parameters()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.QuantumLayer.set_sampling_config"><code class="docutils literal notranslate"><span class="pre">QuantumLayer.set_sampling_config()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.QuantumLayer.simple"><code class="docutils literal notranslate"><span class="pre">QuantumLayer.simple()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.QuantumLayer.to"><code class="docutils literal notranslate"><span class="pre">QuantumLayer.to()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.StateGenerator"><code class="docutils literal notranslate"><span class="pre">StateGenerator</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.StateGenerator.generate_state"><code class="docutils literal notranslate"><span class="pre">StateGenerator.generate_state()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#merlin.core.StatePattern"><code class="docutils literal notranslate"><span class="pre">StatePattern</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.StatePattern.DEFAULT"><code class="docutils literal notranslate"><span class="pre">StatePattern.DEFAULT</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.StatePattern.SPACED"><code class="docutils literal notranslate"><span class="pre">StatePattern.SPACED</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.StatePattern.SEQUENTIAL"><code class="docutils literal notranslate"><span class="pre">StatePattern.SEQUENTIAL</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.html#merlin.core.StatePattern.PERIODIC"><code class="docutils literal notranslate"><span class="pre">StatePattern.PERIODIC</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.core.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.ansatz.html">merlin.core.ansatz module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.ansatz.html#merlin.core.ansatz.Ansatz"><code class="docutils literal notranslate"><span class="pre">Ansatz</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.ansatz.html#merlin.core.ansatz.AnsatzFactory"><code class="docutils literal notranslate"><span class="pre">AnsatzFactory</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.ansatz.html#merlin.core.ansatz.CircuitGenerator"><code class="docutils literal notranslate"><span class="pre">CircuitGenerator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.ansatz.html#merlin.core.ansatz.ComputationProcessFactory"><code class="docutils literal notranslate"><span class="pre">ComputationProcessFactory</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.ansatz.html#merlin.core.ansatz.FeatureEncoder"><code class="docutils literal notranslate"><span class="pre">FeatureEncoder</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.ansatz.html#merlin.core.ansatz.OutputMappingStrategy"><code class="docutils literal notranslate"><span class="pre">OutputMappingStrategy</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.ansatz.html#merlin.core.ansatz.PhotonicBackend"><code class="docutils literal notranslate"><span class="pre">PhotonicBackend</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.ansatz.html#merlin.core.ansatz.StateGenerator"><code class="docutils literal notranslate"><span class="pre">StateGenerator</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.base.html">merlin.core.base module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.base.html#merlin.core.base.ABC"><code class="docutils literal notranslate"><span class="pre">ABC</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.base.html#merlin.core.base.AbstractComputationProcess"><code class="docutils literal notranslate"><span class="pre">AbstractComputationProcess</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.base.html#merlin.core.base.abstractmethod"><code class="docutils literal notranslate"><span class="pre">abstractmethod()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.generators.html">merlin.core.generators module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.generators.html#merlin.core.generators.CircuitGenerator"><code class="docutils literal notranslate"><span class="pre">CircuitGenerator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.generators.html#merlin.core.generators.CircuitType"><code class="docutils literal notranslate"><span class="pre">CircuitType</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.generators.html#merlin.core.generators.Enum"><code class="docutils literal notranslate"><span class="pre">Enum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.generators.html#merlin.core.generators.StateGenerator"><code class="docutils literal notranslate"><span class="pre">StateGenerator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.generators.html#merlin.core.generators.StatePattern"><code class="docutils literal notranslate"><span class="pre">StatePattern</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.layer.html">merlin.core.layer module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.layer.html#merlin.core.layer.Ansatz"><code class="docutils literal notranslate"><span class="pre">Ansatz</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.layer.html#merlin.core.layer.AnsatzFactory"><code class="docutils literal notranslate"><span class="pre">AnsatzFactory</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.layer.html#merlin.core.layer.AutoDiffProcess"><code class="docutils literal notranslate"><span class="pre">AutoDiffProcess</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.layer.html#merlin.core.layer.CircuitType"><code class="docutils literal notranslate"><span class="pre">CircuitType</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.layer.html#merlin.core.layer.ComputationProcessFactory"><code class="docutils literal notranslate"><span class="pre">ComputationProcessFactory</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.layer.html#merlin.core.layer.Experiment"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.layer.html#merlin.core.layer.OutputMapper"><code class="docutils literal notranslate"><span class="pre">OutputMapper</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.layer.html#merlin.core.layer.OutputMappingStrategy"><code class="docutils literal notranslate"><span class="pre">OutputMappingStrategy</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.layer.html#merlin.core.layer.QuantumLayer"><code class="docutils literal notranslate"><span class="pre">QuantumLayer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.layer.html#merlin.core.layer.StatePattern"><code class="docutils literal notranslate"><span class="pre">StatePattern</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.photonicbackend.html">merlin.core.photonicbackend module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.photonicbackend.html#merlin.core.photonicbackend.CircuitType"><code class="docutils literal notranslate"><span class="pre">CircuitType</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.photonicbackend.html#merlin.core.photonicbackend.PhotonicBackend"><code class="docutils literal notranslate"><span class="pre">PhotonicBackend</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.photonicbackend.html#merlin.core.photonicbackend.StatePattern"><code class="docutils literal notranslate"><span class="pre">StatePattern</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.core.process.html">merlin.core.process module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.process.html#merlin.core.process.AbstractComputationProcess"><code class="docutils literal notranslate"><span class="pre">AbstractComputationProcess</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.process.html#merlin.core.process.CircuitConverter"><code class="docutils literal notranslate"><span class="pre">CircuitConverter</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.process.html#merlin.core.process.ComputationProcess"><code class="docutils literal notranslate"><span class="pre">ComputationProcess</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.process.html#merlin.core.process.ComputationProcessFactory"><code class="docutils literal notranslate"><span class="pre">ComputationProcessFactory</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.core.process.html#merlin.core.process.build_slos_distribution_computegraph"><code class="docutils literal notranslate"><span class="pre">build_slos_distribution_computegraph()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="merlin.datasets.html">merlin.datasets package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.characteristics"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.characteristics</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.citation"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.citation</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.creators"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.creators</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.description"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.description</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.feature_relationships"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.feature_relationships</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.features"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.features</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.from_dict"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.from_dict()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.homepage"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.homepage</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.license"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.license</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.name"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.name</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.normalization"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.normalization</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.num_classes"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.num_classes</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.num_features"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.num_features</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.num_instances"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.num_instances</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.subset"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.subset</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.task_type"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.task_type</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.to_dict"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.to_dict()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.html#merlin.datasets.DatasetMetadata.year"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata.year</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.datasets.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.metadata.html">merlin.datasets.metadata module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.metadata.html#merlin.datasets.metadata.DatasetMetadata"><code class="docutils literal notranslate"><span class="pre">DatasetMetadata</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.metadata.html#merlin.datasets.metadata.Feature"><code class="docutils literal notranslate"><span class="pre">Feature</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.metadata.html#merlin.datasets.metadata.FeatureNormalization"><code class="docutils literal notranslate"><span class="pre">FeatureNormalization</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.metadata.html#merlin.datasets.metadata.Normalization"><code class="docutils literal notranslate"><span class="pre">Normalization</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.iris.html">merlin.datasets.iris module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.iris.html#merlin.datasets.iris.get_data_test"><code class="docutils literal notranslate"><span class="pre">get_data_test()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.iris.html#merlin.datasets.iris.get_data_train"><code class="docutils literal notranslate"><span class="pre">get_data_train()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.mnist_digits.html">merlin.datasets.mnist_digits module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.mnist_digits.html#merlin.datasets.mnist_digits.get_data_test_original"><code class="docutils literal notranslate"><span class="pre">get_data_test_original()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.mnist_digits.html#merlin.datasets.mnist_digits.get_data_test_percevalquest"><code class="docutils literal notranslate"><span class="pre">get_data_test_percevalquest()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.mnist_digits.html#merlin.datasets.mnist_digits.get_data_train_original"><code class="docutils literal notranslate"><span class="pre">get_data_train_original()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.mnist_digits.html#merlin.datasets.mnist_digits.get_data_train_percevalquest"><code class="docutils literal notranslate"><span class="pre">get_data_train_percevalquest()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.spiral.html">merlin.datasets.spiral module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.spiral.html#merlin.datasets.spiral.get_data"><code class="docutils literal notranslate"><span class="pre">get_data()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.datasets.utils.html">merlin.datasets.utils module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.utils.html#merlin.datasets.utils.df_to_xy"><code class="docutils literal notranslate"><span class="pre">df_to_xy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.utils.html#merlin.datasets.utils.fetch"><code class="docutils literal notranslate"><span class="pre">fetch()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.datasets.utils.html#merlin.datasets.utils.read_idx"><code class="docutils literal notranslate"><span class="pre">read_idx()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="merlin.pcvl_pytorch.html">merlin.pcvl_pytorch package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="merlin.pcvl_pytorch.html#merlin.pcvl_pytorch.CircuitConverter"><code class="docutils literal notranslate"><span class="pre">CircuitConverter</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.pcvl_pytorch.html#merlin.pcvl_pytorch.CircuitConverter.set_dtype"><code class="docutils literal notranslate"><span class="pre">CircuitConverter.set_dtype()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.pcvl_pytorch.html#merlin.pcvl_pytorch.CircuitConverter.to"><code class="docutils literal notranslate"><span class="pre">CircuitConverter.to()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.pcvl_pytorch.html#merlin.pcvl_pytorch.CircuitConverter.to_tensor"><code class="docutils literal notranslate"><span class="pre">CircuitConverter.to_tensor()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.pcvl_pytorch.html#merlin.pcvl_pytorch.build_slos_distribution_computegraph"><code class="docutils literal notranslate"><span class="pre">build_slos_distribution_computegraph()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="merlin.pcvl_pytorch.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html">merlin.pcvl_pytorch.locirc_to_tensor module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.AComponent"><code class="docutils literal notranslate"><span class="pre">AComponent</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.BS"><code class="docutils literal notranslate"><span class="pre">BS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.BSConvention"><code class="docutils literal notranslate"><span class="pre">BSConvention</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.Barrier"><code class="docutils literal notranslate"><span class="pre">Barrier</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.Circuit"><code class="docutils literal notranslate"><span class="pre">Circuit</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.CircuitConverter"><code class="docutils literal notranslate"><span class="pre">CircuitConverter</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.PERM"><code class="docutils literal notranslate"><span class="pre">PERM</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.PS"><code class="docutils literal notranslate"><span class="pre">PS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.SUPPORTED_COMPONENTS"><code class="docutils literal notranslate"><span class="pre">SUPPORTED_COMPONENTS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.Unitary"><code class="docutils literal notranslate"><span class="pre">Unitary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.locirc_to_tensor.html#merlin.pcvl_pytorch.locirc_to_tensor.dispatch"><code class="docutils literal notranslate"><span class="pre">dispatch()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.pcvl_pytorch.slos_torchscript.html">merlin.pcvl_pytorch.slos_torchscript module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.slos_torchscript.html#merlin.pcvl_pytorch.slos_torchscript.Callable"><code class="docutils literal notranslate"><span class="pre">Callable</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.slos_torchscript.html#merlin.pcvl_pytorch.slos_torchscript.SLOSComputeGraph"><code class="docutils literal notranslate"><span class="pre">SLOSComputeGraph</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.slos_torchscript.html#merlin.pcvl_pytorch.slos_torchscript.build_slos_distribution_computegraph"><code class="docutils literal notranslate"><span class="pre">build_slos_distribution_computegraph()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.slos_torchscript.html#merlin.pcvl_pytorch.slos_torchscript.compute_slos_distribution"><code class="docutils literal notranslate"><span class="pre">compute_slos_distribution()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.slos_torchscript.html#merlin.pcvl_pytorch.slos_torchscript.layer_compute_backward"><code class="docutils literal notranslate"><span class="pre">layer_compute_backward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.slos_torchscript.html#merlin.pcvl_pytorch.slos_torchscript.layer_compute_vectorized"><code class="docutils literal notranslate"><span class="pre">layer_compute_vectorized()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.slos_torchscript.html#merlin.pcvl_pytorch.slos_torchscript.load_slos_distribution_computegraph"><code class="docutils literal notranslate"><span class="pre">load_slos_distribution_computegraph()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.pcvl_pytorch.slos_torchscript.html#merlin.pcvl_pytorch.slos_torchscript.prepare_vectorized_operations"><code class="docutils literal notranslate"><span class="pre">prepare_vectorized_operations()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="merlin.sampling.html">merlin.sampling package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.AutoDiffProcess"><code class="docutils literal notranslate"><span class="pre">AutoDiffProcess</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.AutoDiffProcess.autodiff_backend"><code class="docutils literal notranslate"><span class="pre">AutoDiffProcess.autodiff_backend()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.LexGroupingMapper"><code class="docutils literal notranslate"><span class="pre">LexGroupingMapper</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.LexGroupingMapper.forward"><code class="docutils literal notranslate"><span class="pre">LexGroupingMapper.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.ModGroupingMapper"><code class="docutils literal notranslate"><span class="pre">ModGroupingMapper</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.ModGroupingMapper.forward"><code class="docutils literal notranslate"><span class="pre">ModGroupingMapper.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.OutputMapper"><code class="docutils literal notranslate"><span class="pre">OutputMapper</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.OutputMapper.create_mapping"><code class="docutils literal notranslate"><span class="pre">OutputMapper.create_mapping()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.OutputMappingStrategy"><code class="docutils literal notranslate"><span class="pre">OutputMappingStrategy</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.OutputMappingStrategy.LINEAR"><code class="docutils literal notranslate"><span class="pre">OutputMappingStrategy.LINEAR</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.OutputMappingStrategy.GROUPING"><code class="docutils literal notranslate"><span class="pre">OutputMappingStrategy.GROUPING</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.OutputMappingStrategy.LEXGROUPING"><code class="docutils literal notranslate"><span class="pre">OutputMappingStrategy.LEXGROUPING</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.OutputMappingStrategy.MODGROUPING"><code class="docutils literal notranslate"><span class="pre">OutputMappingStrategy.MODGROUPING</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.OutputMappingStrategy.NONE"><code class="docutils literal notranslate"><span class="pre">OutputMappingStrategy.NONE</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.SamplingProcess"><code class="docutils literal notranslate"><span class="pre">SamplingProcess</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.html#merlin.sampling.SamplingProcess.pcvl_sampler"><code class="docutils literal notranslate"><span class="pre">SamplingProcess.pcvl_sampler()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.sampling.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.autodiff.html">merlin.sampling.autodiff module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.sampling.autodiff.html#merlin.sampling.autodiff.AutoDiffProcess"><code class="docutils literal notranslate"><span class="pre">AutoDiffProcess</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.sampling.autodiff.html#merlin.sampling.autodiff.SamplingProcess"><code class="docutils literal notranslate"><span class="pre">SamplingProcess</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.mappers.html">merlin.sampling.mappers module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.sampling.mappers.html#merlin.sampling.mappers.LexGroupingMapper"><code class="docutils literal notranslate"><span class="pre">LexGroupingMapper</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.sampling.mappers.html#merlin.sampling.mappers.ModGroupingMapper"><code class="docutils literal notranslate"><span class="pre">ModGroupingMapper</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.sampling.mappers.html#merlin.sampling.mappers.OutputMapper"><code class="docutils literal notranslate"><span class="pre">OutputMapper</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.sampling.mappers.html#merlin.sampling.mappers.OutputMappingStrategy"><code class="docutils literal notranslate"><span class="pre">OutputMappingStrategy</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.process.html">merlin.sampling.process module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.sampling.process.html#merlin.sampling.process.SamplingProcess"><code class="docutils literal notranslate"><span class="pre">SamplingProcess</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="merlin.sampling.strategies.html">merlin.sampling.strategies module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.sampling.strategies.html#merlin.sampling.strategies.Enum"><code class="docutils literal notranslate"><span class="pre">Enum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.sampling.strategies.html#merlin.sampling.strategies.OutputMappingStrategy"><code class="docutils literal notranslate"><span class="pre">OutputMappingStrategy</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="merlin.torch_utils.html">merlin.torch_utils package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="merlin.torch_utils.html#merlin.torch_utils.FeatureEncoder"><code class="docutils literal notranslate"><span class="pre">FeatureEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.torch_utils.html#merlin.torch_utils.FeatureEncoder.encode"><code class="docutils literal notranslate"><span class="pre">FeatureEncoder.encode()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="merlin.torch_utils.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="merlin.torch_utils.torch_codes.html">merlin.torch_utils.torch_codes module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="merlin.torch_utils.torch_codes.html#merlin.torch_utils.torch_codes.CircuitType"><code class="docutils literal notranslate"><span class="pre">CircuitType</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="merlin.torch_utils.torch_codes.html#merlin.torch_utils.torch_codes.FeatureEncoder"><code class="docutils literal notranslate"><span class="pre">FeatureEncoder</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</section>
</section>

 
           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="modules.html" class="btn btn-neutral float-left" title="API Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="merlin.core.html" class="btn btn-neutral float-right" title="merlin.core package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Merlin team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>